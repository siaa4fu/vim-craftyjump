scriptencoding utf-8
" the text 'themis#suite()' is required to run test#viml#themis#test_file()
Describe word-motions

let s:expect = function(themis#helper('expect'))

function! s:init_test_buffer()
  new | only!
  let lines = readfile('test/sample_text')
  for lnum in range(1, len(lines))
    call setline(lnum, lines[lnum - 1])
  endfor
endfunction

function! s:getKwdIndices(line, motion)
  " @param {string} line
  " @param {'w' | 'b' | 'e' | 'ge'} motion
  "   'w'  - get start positions of matches and return their indices
  "   'b'  - get start positions of matches and return their indices reversed
  "   'e'  - get end positions of matches and return their indices
  "   'ge' - get end positions of matches and return their indices reversed
  " @return {list<number>} - character indices of keyword characters
  let indices = []
  let Put = function(a:motion ==# 'w' || a:motion ==# 'e' ? 'add' : 'insert', [indices])
  " partial support for word motions in Japanese (:h word)
  let ptn_word = join([
        "\ letters, digits and underscores
        \  '\w\+',
        "\ Hiragana
        \  '[\u3040-\u309f]\+',
        "\ Katakana
        \  '[\u30a0-\u30ff]\+',
        "\ other non-blank characters (including CJK Ideographs)
        \  '\%(\W\&[^\u3040-\u309f\u30a0-\u30ff]\&\k\)\+'
        \], '\|')
  let pos = matchstrpos(a:line, ptn_word) " 0-based byte index
  if a:motion ==# 'w' || a:motion ==# 'b'
    while pos[0] !=# ''
      " matchstrpos(...)[1] gives the 0-based byte index of the starting position of the match
      call Put(charidx(a:line, pos[1]) + 1) " convert 0-based character index to 1-based character index
      let pos = matchstrpos(a:line, ptn_word, pos[2])
    endwhile
  else
    while pos[0] !=# ''
      " matchstrpos(...)[2] gives the 0-based byte index of the first character AFTER the match
      call Put(charidx(a:line, pos[2])) " equal to 1-based character index
      let pos = matchstrpos(a:line, ptn_word, pos[2])
    endwhile
  endif
  return indices
endfunction

function! s:moveInLine(lnum, motion, ...)
  " @param {number} lnum - move in the line with the specified line number
  " @param {'w' | 'b' | 'e' | 'ge'} motion
  " @param {list<number>=?} a:1 - character indices of keyword characters
  " @return {number} - next line number
  let indices = get(a:, 1, s:getKwdIndices(getline(a:lnum), a:motion))
  for index in indices
    execute "normal \<Plug>(craftyjump-word-" . a:motion . ')'
    call s:expect(v:null).to_be_at_position([a:lnum, index])
  endfor
  return a:lnum + (a:motion ==# 'w' || a:motion ==# 'e' ? 1 : -1)
endfunction

Context simple moving
  Before
    call s:init_test_buffer()
  End
  It moves forward using 'w' from the first line
    let lnum = 1
    execute 'normal!' lnum . 'gg0'
    " skip if the initial position is a keyword character
    let lnum = s:moveInLine(lnum, 'w', {indices ->
          \ get(indices, 0, -1) == 1 ? indices[1 :] : indices
          \}(s:getKwdIndices(getline(lnum), 'w')))
    while lnum <= line('$')
      let lnum = s:moveInLine(lnum, 'w')
    endwhile
    " extra move
    let lnum -= 1
    execute "normal \<Plug>(craftyjump-word-w)"
    call s:expect(v:null).to_be_at_position([lnum, strcharlen(getline(lnum))])
  End
  It moves backward using 'b' from the last line
    let lnum = line('$')
    execute 'normal!' lnum . 'gg$'
    " skip if the initial position is a keyword character
    let lnum = s:moveInLine(lnum, 'b', {indices ->
          \ get(indices, 0, -1) == strcharlen(getline(lnum)) ? indices[1 :] : indices
          \}(s:getKwdIndices(getline(lnum), 'b')))
    while lnum > 0
      let lnum = s:moveInLine(lnum, 'b')
    endwhile
    " extra move
    let lnum += 1
    execute "normal \<Plug>(craftyjump-word-b)"
    call s:expect(v:null).to_be_at_position([lnum, 1])
  End
  It moves forward using 'e' from the first line
    let lnum = 1
    execute 'normal!' lnum . 'gg0'
    " skip if the initial position is a keyword character
    let lnum = s:moveInLine(lnum, 'e', {indices ->
          \ get(indices, 0, -1) == 1 ? indices[1 :] : indices
          \}(s:getKwdIndices(getline(lnum), 'e')))
    while lnum <= line('$')
      let lnum = s:moveInLine(lnum, 'e')
    endwhile
    " extra move
    let lnum -= 1
    execute "normal \<Plug>(craftyjump-word-e)"
    call s:expect(v:null).to_be_at_position([lnum, strcharlen(getline(lnum))])
  End
  It moves backward using 'ge' from the last line
    let lnum = line('$')
    execute 'normal!' lnum . 'gg$'
    " skip if the initial position is a keyword character
    let lnum = s:moveInLine(lnum, 'ge', {indices ->
          \ get(indices, 0, -1) == strcharlen(getline(2)) ? indices[1 :] : indices
          \}(s:getKwdIndices(getline(lnum), 'ge')))
    while lnum > 0
      let lnum = s:moveInLine(lnum, 'ge')
    endwhile
    " extra move
    let lnum += 1
    execute "normal \<Plug>(craftyjump-word-ge)"
    call s:expect(v:null).to_be_at_position([lnum, 1])
  End
End

End
