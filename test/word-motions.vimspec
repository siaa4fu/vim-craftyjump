scriptencoding utf-8
" the text 'themis#suite()' is required to run test#viml#themis#test_file()
Describe word-motions

let s:expect = function(themis#helper('expect'))

function! s:init_test_buffer(lines)
  " @param {list<string>} lines - set lines in the test buffer
  new | only!
  for lnum in range(1, len(a:lines))
    call setline(lnum, a:lines[lnum - 1])
  endfor
endfunction

Context using as simple motions
  function! s:getKwdIndices(line, motion)
    " @param {string} line
    " @param {'w' | 'b' | 'e' | 'ge'} motion
    "   'w'  - get start positions of matches and return their indices
    "   'b'  - get start positions of matches and return their indices reversed
    "   'e'  - get end positions of matches and return their indices
    "   'ge' - get end positions of matches and return their indices reversed
    " @return {list<number>} - character indices of keyword characters
    let indices = []
    let Put = function(a:motion ==# 'w' || a:motion ==# 'e' ? 'add' : 'insert', [indices])
    " partial support for word motions in Japanese (`word`)
    let ptn_word = join([
          "\ letters, digits and underscores
          \  '\w\+',
          "\ Hiragana
          \  '[\u3040-\u309f]\+',
          "\ Katakana
          \  '[\u30a0-\u30ff]\+',
          "\ other non-blank characters (including CJK Ideographs)
          \  '\%(\W\&[^\u3040-\u309f\u30a0-\u30ff]\&\k\)\+'
          \], '\|')
    let pos = matchstrpos(a:line, ptn_word) " 0-based byte index
    if a:motion ==# 'w' || a:motion ==# 'b'
      while pos[0] !=# ''
        " matchstrpos(...)[1] gives the 0-based byte index of the starting position of the match
        call Put(charidx(a:line, pos[1]) + 1) " convert 0-based character index to 1-based character index
        let pos = matchstrpos(a:line, ptn_word, pos[2])
      endwhile
    else
      while pos[0] !=# ''
        " matchstrpos(...)[2] gives the 0-based byte index of the first character AFTER the match
        call Put(charidx(a:line, pos[2])) " equal to 1-based character index
        let pos = matchstrpos(a:line, ptn_word, pos[2])
      endwhile
    endif
    return indices
  endfunction

  function! s:moveInLine(lnum, motion, isInitialLine)
    " @param {number} lnum - move in the line with the specified line number
    " @param {'w' | 'b' | 'e' | 'ge'} motion
    " @param {bool} isInitialLine - skip the initial position even if it is a keyword character
    " @return {number} - next line number
    let isForward = a:motion ==# 'w' || a:motion ==# 'e' ? 1 : 0
    let line = getline(a:lnum)
    " skip if the line is blank
    if line !=# ''
      let indices = s:getKwdIndices(line, a:motion)
      if isForward
        " skip the initial position
        if a:isInitialLine && get(indices, 0, -1) == 1 | let indices = indices[1 :] | endif
        " move to the last character of the line before moving to the next line
        let lineEnd = strcharlen(matchstr(line, '^.\{-}\ze\s*$'))
        if get(indices, -1, -1) != lineEnd | call add(indices, lineEnd) | endif
      else
        " skip the initial position
        if a:isInitialLine && get(indices, 0, -1) == strcharlen(line) | let indices = indices[1 :] | endif
        " move to the first character of the line before moving to the previous line
        let lineStart = strcharlen(matchstr(line, '^\s*')) + 1
        if get(indices, -1, -1) != lineStart | call add(indices, lineStart) | endif
      endif
      for index in indices
        execute "normal \<Plug>(craftyjump-word-" . a:motion . ')'
        call s:expect(v:null).to_be_at_position([a:lnum, index])
      endfor
    endif
    return a:lnum + (isForward ? 1 : -1)
  endfunction

  Before
    call s:init_test_buffer(readfile('test/sample_text'))
  End
  It moves forward using 'w' from the first line
    let lnum = 1
    execute 'normal!' lnum . 'gg0'
    let lnum = s:moveInLine(lnum, 'w', v:true)
    while lnum <= line('$')
      let lnum = s:moveInLine(lnum, 'w', v:false)
    endwhile
    " extra move
    let lnum -= 1
    execute "normal \<Plug>(craftyjump-word-w)"
    call s:expect(v:null).to_be_at_position([lnum, '$'])
  End
  It moves backward using 'b' from the last line
    let lnum = line('$')
    execute 'normal!' lnum . 'gg$'
    let lnum = s:moveInLine(lnum, 'b', v:true)
    while lnum > 0
      let lnum = s:moveInLine(lnum, 'b', v:false)
    endwhile
    " extra move
    let lnum += 1
    execute "normal \<Plug>(craftyjump-word-b)"
    call s:expect(v:null).to_be_at_position([lnum, '0'])
  End
  It moves forward using 'e' from the first line
    let lnum = 1
    execute 'normal!' lnum . 'gg0'
    let lnum = s:moveInLine(lnum, 'e', v:true)
    while lnum <= line('$')
      let lnum = s:moveInLine(lnum, 'e', v:false)
    endwhile
    " extra move
    let lnum -= 1
    execute "normal \<Plug>(craftyjump-word-e)"
    call s:expect(v:null).to_be_at_position([lnum, '$'])
  End
  It moves backward using 'ge' from the last line
    let lnum = line('$')
    execute 'normal!' lnum . 'gg$'
    let lnum = s:moveInLine(lnum, 'ge', v:true)
    while lnum > 0
      let lnum = s:moveInLine(lnum, 'ge', v:false)
    endwhile
    " extra move
    let lnum += 1
    execute "normal \<Plug>(craftyjump-word-ge)"
    call s:expect(v:null).to_be_at_position([lnum, '0'])
  End
End

Context using as operators
  Before
    call s:init_test_buffer(['aaa [bbb] ccc', 'あああ [いいい] ううう'])
  End
  It deletes a word using 'w'
    normal! gg0
    " delete a word (exclusive)
    execute "normal d\<Plug>(craftyjump-word-w)"
    call s:expect(getline('.')).to_equal('bbb] ccc')
    " repeat
    normal! .
    call s:expect(getline('.')).to_equal('ccc')
    " repeat
    normal! .
    call s:expect(getline('.')).to_equal('')
    " repeat
    normal! .
    call s:expect(getline('.')).to_equal('あああ [いいい] ううう')
    " delete 2 words
    execute "normal d2\<Plug>(craftyjump-word-w)"
    call s:expect(getline('.')).to_equal('ううう')
  End
  It deletes a word using 'b'
    normal! G$
    " delete a word (exclusive)
    execute "normal d\<Plug>(craftyjump-word-b)"
    call s:expect(getline('.')).to_equal('あああ [いいい] う')
    " repeat
    normal! .
    call s:expect(getline('.')).to_equal('あああ [う')
    " repeat
    normal! .
    call s:expect(getline('.')).to_equal('う')
    " repeat (also remove an end-of-line unlike default 'b')
    normal! .
    call s:expect(getline('.')).to_equal('aaa [bbb] う')
    " delete 2 words
    execute "normal d2\<Plug>(craftyjump-word-b)"
    call s:expect(getline('.')).to_equal('う')
  End
  It deletes a word using 'e'
    normal! gg0
    " delete a word (inclusive)
    execute "normal d\<Plug>(craftyjump-word-e)"
    call s:expect(getline('.')).to_equal(' [bbb] ccc')
    " repeat
    normal! .
    call s:expect(getline('.')).to_equal('] ccc')
    " repeat
    normal! .
    call s:expect(getline('.')).to_equal('')
    " repeat
    normal! .
    call s:expect(getline('.')).to_equal(' [いいい] ううう')
    " delete 2 words
    execute "normal d2\<Plug>(craftyjump-word-e)"
    call s:expect(getline('.')).to_equal('')
  End
  It deletes a word using 'ge'
    normal! G$
    " delete a word (inclusive)
    execute "normal d\<Plug>(craftyjump-word-ge)"
    call s:expect(getline('.')).to_equal('あああ [いい')
    " repeat
    normal! .
    call s:expect(getline('.')).to_equal('ああ')
    " repeat (stop at the first character of the line unlike default 'ge')
    normal! .
    call s:expect(getline('.')).to_equal('')
    " repeat
    normal! .
    call s:expect(getline('.')).to_equal('aaa [bbb] cc')
    " delete 2 words
    execute "normal d2\<Plug>(craftyjump-word-ge)"
    call s:expect(getline('.')).to_equal('aa')
  End
End

End
